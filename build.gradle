buildscript {
	repositories {
		jcenter()
		maven {
			name "Modmuss50 Repository"
			url 'https://maven.modmuss50.me'
		}
	}
	dependencies {
		classpath "net.fabricmc:weave:0.3.0.+"
		classpath "net.fabricmc:stitch:0.1.1.43"
		classpath "commons-io:commons-io:1.4"
		classpath "com.google.guava:guava:19.0"
		classpath 'de.undercouch:gradle-download-task:3.4.3'
		classpath 'net.fabricmc:tiny-remapper:+'
	}
}

plugins {
	id 'de.undercouch.download' version '3.4.3'
	id 'maven'
	id 'maven-publish'
}

def starmade_version = project.hasProperty("starMadeVersion")
	? project.starMadeVersion
	: "0.201.364"

logger.lifecycle(": Targeting StarMade $starmade_version")

def ENV = System.getenv()
// Fetch build number from Jenkins
def build_number = ENV.BUILD_NUMBER ?: "local"

def yarnVersion = "${starmade_version}.$build_number"


repositories {
	mavenCentral()
	maven {
		name "Modmuss50 Repository"
		url 'https://maven.modmuss50.me'
	}
}

configurations {
	enigmaRuntime {
		resolutionStrategy {
			cacheDynamicVersionsFor 0, "seconds"
			cacheChangingModulesFor 0, "seconds"
		}
	}
}

dependencies {
	enigmaRuntime "net.fabricmc:stitch:0.1.1.39+"
	enigmaRuntime "cuchaz:enigma:0.13.1.+:all"
}

def mappingsDir = file("mappings")
def cacheFilesStarMade = file(".gradle/starmade")
def tempDir = file(".gradle/temp")
def intermediaryJar = file("${starmade_version}-intermediary.jar")
def namedJar = file("${starmade_version}-named.jar")
def checksumsFile = new File(cacheFilesStarMade, "${starmade_version}_checksums.lst")
def gameJar = new File(cacheFilesStarMade, "${starmade_version}.jar")
def libraries = new File(cacheFilesStarMade, "${starmade_version}-libraries")
def libs = new File("build/libs/")

ext.baseUrl = new URL("http://files.star-made.org/")

import groovy.json.JsonSlurper
import org.apache.commons.io.FileUtils
import com.google.common.hash.Hashing
import com.google.common.io.Files
import net.fabricmc.stitch.commands.CommandMergeTiny
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils
import net.fabricmc.weave.CommandTinyify
import net.fabricmc.weave.CommandFindMappingErrors
import groovy.io.FileType
import java.util.zip.GZIPOutputStream

boolean validateChecksum(File file, String checksum) {
	if (file != null) {
		def hash = Files.hash(file, Hashing.sha1())
		def builder = new StringBuilder()
		hash.asBytes().each {
			builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
		}
		return builder.toString().equals(checksum)
	}
	return false
}

task downloadVersionsManifest {
	inputs.property "sm_ver", starmade_version
	inputs.property "currenttime", new Date()
	def manifestFile = new File(cacheFilesStarMade, "release_version_manifest.lst")
	outputs.file(manifestFile)
	doLast {
		logger.lifecycle(":downloading starmade release versions manifest")
		FileUtils.copyURLToFile(new URL(baseUrl, "/releasebuildindex"), manifestFile)
	}
}

def getManifestVersion(File manifestFile, String starmade_version) {
	def manifest = manifestFile.exists() ? FileUtils.readLines(manifestFile, "UTF-8") : null
	def tokens = manifest != null ?
		manifest.stream().findAll({it.startsWith(starmade_version + "#") ? it : null}).last().tokenize(' ')
		: null
	if (tokens == null)
		return java.util.Optional.empty()

	def build_id = tokens[0].split('#')
	return java.util.Optional.of([
			version: build_id[0],
			build: build_id[1],
			path: tokens[1],
			checksums: new URL(baseUrl, "${tokens[1]}/checksums")
		])
}

task downloadWantedVersionManifest(dependsOn: downloadVersionsManifest) {
	def manifestFile = downloadVersionsManifest.outputs.files.singleFile
	def manifestVersion = getManifestVersion(manifestFile, starmade_version)

	//have to grab the release time as there's a current timestamp on each element?!
	inputs.property "releaseTime", manifestVersion.isPresent() ? manifestVersion.get().build : -1
	inputs.property "downloadBaseUrl", manifestVersion.isPresent() ? new URL(baseUrl, manifestVersion.get().path) : null

	outputs.file checksumsFile

	doLast {
		manifestVersion = getManifestVersion(manifestFile, starmade_version) //nb need to re-read here in case it didn't exist before
		if (manifestVersion.isPresent() || checksumsFile.exists()) {

			if (manifestVersion.isPresent()) {
				FileUtils.copyURLToFile(manifestVersion.get().checksums, checksumsFile)
			}
		} else {
			throw new RuntimeException("No version data for Minecraft version ${starmade_version}")
		}
	}

}

task downloadStarMadeJars(dependsOn: downloadWantedVersionManifest) {
	def manifestFile = downloadVersionsManifest.outputs.files.singleFile
	def manifestVersion = getManifestVersion(manifestFile, starmade_version)

	inputs.files checksumsFile

	outputs.files(gameJar)

	outputs.upToDateWhen {
		def version = FileUtils.readLines(checksumsFile, "UTF-8")
		def sha1 = version.stream().findResult({it.startsWith("./StarMade.jar ") ? it : null}).tokenize(" ")[2]
		return gameJar.exists() && validateChecksum(gameJar, sha1)
	}

	doLast {
		if (!checksumsFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${checksumsFile.name} file!")
		}

		//reload in case it changed
		def version = FileUtils.readLines(checksumsFile)
		def sha1 = version.stream().findResult({it.startsWith("./StarMade.jar ") ? it : null}).tokenize(" ")[2]

		if (!gameJar.exists() || !validateChecksum(gameJar, sha1)) {
			logger.lifecycle(":downloading StarMade.jar ($sha1)")
			FileUtils.copyURLToFile(new URL(baseUrl, "${manifestVersion.get().path}/StarMade.jar"), gameJar)
		}
	}
}

task setupYarn(dependsOn: downloadStarMadeJars) {

}

task yarn(dependsOn: setupYarn) {
	doLast {
		ant.java(
			classname: 'cuchaz.enigma.Main',
			classpath: configurations.enigmaRuntime.asPath,
			fork: true,
			spawn: true
		) {
			arg(value: gameJar.getAbsolutePath())
			arg(value: mappingsDir.getAbsolutePath())
		}
	}
}

task buildEnigma(type: Zip) {
	from mappingsDir
	include "**/*"
	archiveName "yarn-enigma-${yarnVersion}.zip"
	destinationDir(file("build/libs"))
}

task checkMappings {
	inputs.dir mappingsDir
	doLast {
		logger.lifecycle(":checking mappings")

		String[] args = [
			gameJar.getAbsolutePath(),
			mappingsDir.getAbsolutePath()
		]

		new CommandFindMappingErrors().run(args)
	}
}

task downloadIntermediary(type: Download){
	src "https://github.com/DistortSM/intermediary/raw/master/mappings/${starmade_version}.tiny"
	dest new File(cacheFilesStarMade, "${starmade_version}-intermediary.tiny")
}

task buildYarnTiny(dependsOn: "downloadStarMadeJars", type: FileOutput) {
	inputs.dir mappingsDir
	if (!libs.exists()) {
		libs.mkdirs()
	}

	def yarnTiny = new File(tempDir, "yarn-mappings.tiny")
	fileOutput = yarnTiny

	outputs.upToDateWhen {return false}

	doLast {
		logger.lifecycle(":generating tiny mappings")

		String[] args = [
			gameJar.getAbsolutePath(),
			mappingsDir.getAbsolutePath(),
			yarnTiny.getAbsolutePath(),
			"official",
			"named"
		]

		new CommandTinyify().run(args)
	}
}

task mergeTiny(dependsOn: ["buildYarnTiny", "downloadIntermediary"], type: FileOutput) {
	def yarnTinyInput = buildYarnTiny.fileOutput
	def intermediaryTinyInput = downloadIntermediary.dest

	def outputFile = new File(tempDir, "mappings.tiny")
	outputs.file(outputFile)
	fileOutput = outputFile

	outputs.upToDateWhen {return false}

	doLast {
		logger.lifecycle(":merging yarn and intermediary")
		String[] args = [
			yarnTinyInput.getAbsolutePath(),
			intermediaryTinyInput.getAbsolutePath(),
			outputFile.getAbsolutePath(),
			"intermediary",
			"official"
		]

		new CommandMergeTiny().run(args)
	}
}

task tinyJar(type: Jar, dependsOn: "mergeTiny") {
	outputs.upToDateWhen {return false}
	archiveName = "yarn-${yarnVersion}.jar"
	destinationDir(file("build/libs"))
	classifier = ""
	from (mergeTiny.fileOutput) {
		rename { "mappings/mappings.tiny" }
	}
}

task compressTiny(dependsOn: ["tinyJar", "mergeTiny"], type: FileOutput){
	def outputFile = new File(libs, "yarn-tiny-${yarnVersion}.gz")
	outputs.file(outputFile)
	fileOutput = outputFile

	def inputFile = mergeTiny.fileOutput

	outputs.upToDateWhen {return false}

	doLast {
		logger.lifecycle(":compressing tiny mappings")

		def buffer = new byte[1024]
		def fileOutputStream = new FileOutputStream(outputFile)
		def outputStream = new GZIPOutputStream(fileOutputStream)
		def fileInputStream = new FileInputStream(inputFile)

		def length
		while ((length = fileInputStream.read(buffer)) > 0) {
			outputStream.write(buffer, 0, length)
		}

		fileInputStream.close()
		outputStream.finish()
		outputStream.close()
		inputFile.delete()
	}
}

clean.doFirst {
	delete tempDir, cacheFilesStarMade
}

tasks.build.dependsOn "compressTiny"
tasks.build.dependsOn "buildEnigma"
tasks.build.dependsOn "tinyJar"

task downloadMcLibs(dependsOn: downloadWantedVersionManifest) {
	inputs.files checksumsFile

	outputs.file(libraries)

	outputs.upToDateWhen {
		return false
	}

	doLast {
		if (!checksumsFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${checksumsFile.name} file!")
		}

		def version = new JsonSlurper().parseText(FileUtils.readFileToString(checksumsFile))

		logger.lifecycle(":downloading minecraft libraries")

		if (!libraries.exists()) {
			libraries.mkdirs()
		}

		version.libraries.each {
			def downloadUrl = it.downloads.artifact.url

			download {
				src downloadUrl
				dest new File(libraries, downloadUrl.substring(downloadUrl.lastIndexOf("/") + 1))
				overwrite false
			}
		}
	}
}

task mapIntermediaryJar(dependsOn: [downloadMcLibs, build]) {
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(intermediaryJar)

	//Force the task to always run
	outputs.upToDateWhen {
		return false
	}

	doLast {
		logger.lifecycle(":mapping minecraft to intermdiary")
		def tinyInput = new File("build/libs/yarn-tiny-${yarnVersion}.gz")
		mapJar(intermediaryJar, gameJar, tinyInput, libraries, "official", "intermediary")
	}
}

task mapNamedJar(dependsOn: mapIntermediaryJar) {
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(namedJar)

	//Force the task to always run
	outputs.upToDateWhen {
		return false
	}

	doLast {
		logger.lifecycle(":mapping minecraft to named")

		def tinyInput = new File("build/libs/yarn-tiny-${yarnVersion}.gz")
		mapJar(namedJar, intermediaryJar, tinyInput, libraries, "intermediary", "named")
	}
}

publishing {
	publications {
		maven(MavenPublication) {
			groupId 'net.fabricmc'
			artifactId "yarn"
			version yarnVersion

			artifact (compressTiny.fileOutput) {
				classifier "tiny"
				builtBy compressTiny
			}
			artifact (buildEnigma) {
				classifier "enigma"
			}
			artifact (tinyJar)
		}
	}
	repositories {
		maven {
			url "http://mavenupload.modmuss50.me/"
			if (project.hasProperty('mavenPass')) {
				credentials {
					username 'buildslave'
					password project.getProperty('mavenPass')
				}
			}
		}
	}
}


void mapJar(File output, File input, File mappings, File libraries, String from, String to){
	if (output.exists()) {
		output.delete()
	}

	def remapper = TinyRemapper.newRemapper()
		.withMappings(TinyUtils.createTinyMappingProvider(mappings.toPath(), from, to))
		.renameInvalidLocals(true)
		.rebuildSourceFilenames(true)
		.build()

	try {
		def outputConsumer = new OutputConsumerPath(output.toPath())
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.read(input.toPath())

		libraries.eachFileRecurse(FileType.FILES) {file ->
			remapper.read(file.toPath())
		}
		remapper.apply(input.toPath(), outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e);
	}
}

class FileOutput extends DefaultTask {
	@OutputFile File fileOutput
}
